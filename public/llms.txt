# Kiru Framework - AI/LLM Documentation

## Overview

Kiru is a batteries-included, easy-to-use rendering library with a tiny footprint. It is a lightweight framework designed to empower developers to build applications with expressivity and customizability. Kiru offers routing, state management via signals, asynchronous state, and more — all in one framework without requiring additional dependencies.

**Important: Kiru is NOT a React-like framework.** State & reactivity is managed with **signals** and **computed** values. When a component needs **local state**, it must **return a render function** (a function that returns JSX) so that state created in the component body is persisted across renders. The component body runs once (setup); the returned function is invoked for each render and closes over that state. This lets you build features and functionalities as individual units.

**Key Characteristics:**
- **Performance**: Fine-grained reactivity — only the DOM nodes that observe a signal update when it changes
- **Batteries-Included**: Built-in routing (FileRouter), signals, computed, effect, lifecycles (onMount, onCleanup), Context, Portal, Transition, ViewTransitions, and more
- **TypeScript-first**: Full TypeScript support
- **JSX/TSX syntax**: Component syntax with JSX
- **Reactive state**: Signal-based reactivity with computed values, effects, and two-way binding (`bind:`)
- **File-based routing**: FileRouter with convention-over-configuration
- **SSG support**: Static site generation via vite-plugin-kiru
- **Component model**: Stateless components return JSX; stateful components create signals in the body and return a render function

## Installation & Setup

### Start a New Project

Use the `create-kiru` CLI to scaffold a new Kiru application:

```bash
npx create-kiru
# or with options:
npx create-kiru -d my-kiru-app --template CSR --install --start
```

**Templates:** `CSR` (client-side), `SSG`, `SSR`, `Tauri`

**CLI flags:** `-d, --dir <dir>`, `-t, --template <template>`, `-i, --install`, `-s, --start`. In non-interactive mode, `-d`, `-t`, `-i`, and `-s` are required.

### Add to Existing Project

```bash
npm install kiru
npm install vite-plugin-kiru -D
```

`vite.config.ts`:

```ts
import { defineConfig } from "vite"
import kiru from "vite-plugin-kiru"

export default defineConfig({
  plugins: [kiru()],
})
```

`tsconfig.json`: add `"jsx": "preserve"`.

Simple app and mount:

```tsx
export function App() {
  return <h1>Hello world!</h1>
}
```

```ts
import { mount } from "kiru"
import { App } from "./App"

mount(document.getElementById("app")!, <App />)
```

## Core: Component Model

### Stateless components

Components that need no local state can return JSX directly:

```tsx
function Button(props: { text: string; onClick: () => void }) {
  return (
    <button onclick={props.onClick}>
      {props.text}
    </button>
  )
}
```

### Stateful components: return a render function

When a component has **local state** (signals, refs, etc.), it must **return a function** that returns JSX. That function is the render function; the component body runs once, and the returned function is called on each render. State created in the body is closed over and persists.

```tsx
import { signal } from "kiru"

function Counter() {
  const count = signal(0)

  return () => (
    <div>
      <p>Count: {count}</p>
      <button onclick={() => (count.value += 1)}>Increment</button>
    </div>
  )
}
```

With props, the render function receives them:

```tsx
const Greeter: Kiru.FC<{ name: string }> = (initialProps) => {
  const greeted = signal(false)

  return (currentProps) => (
    <div>
      <p>Hello, {currentProps.name}!</p>
      <button onclick={() => (greeted.value = true)}>Mark greeted</button>
    </div>
  )
}
```

Layout with children:

```tsx
const Layout: Kiru.FC<{ children: JSX.Children }> = ({ children }) => (
  <div className="layout">
    {children}
  </div>
)
```

**Why this model:** You can build features as self-contained units: create signals and logic in the component body, and use lifecycle hooks (onMount, onCleanup) there. No React-like hook rules or dependency arrays.

### Building features as units (no lifecycle hooks in the React sense)

Logic that doesn’t belong in a single component can be extracted into a factory that returns an API. Example: a hash-change dispatcher that uses signals and returns `{ init }` with cleanup:

```ts
export function createHashChangeDispatcher(
  getSectionIds: () => string[],
  router: { setHash: (hash: string, opts?: { replace?: boolean }) => void }
) {

  const handleScroll = () => {
    const sectionIds = getSectionIds()
    // ... compute sectionId from scroll position
    router.setHash(sectionId ? `#${sectionId}` : "", { replace: true })
  }

  const init = () => {
    window.addEventListener("scroll", handleScroll)
    window.addEventListener("resize", handleScroll)
    return () => {
      window.removeEventListener("scroll", handleScroll)
      window.removeEventListener("resize", handleScroll)
    }
  }

  return { init }
}
```

A layout component can call `onMount(() => hashChangeDispatcher.init())` so the cleanup from `init()` runs on unmount. Features stay in one place without being tied to React-like lifecycles.

## Signal — Reactive State

Signals are reactive primitives. Only the parts of the UI that observe a signal update when it changes.

```tsx
import { signal, computed } from "kiru"

const userName = signal("bob")
const userGreeting = computed(() => `Hello, ${userName.value}!`)

console.log(userName.value)
userName.value = "alice"
```

**Signal API:**
- `value`: get/set current value
- `subscribe(fn)`: run when value changes; returns unsubscribe
- `peek()`: read without tracking
- `sneak(v)`: set without notifying
- `notify()`: trigger notification without changing value

**Reactivity via observation:** When you read a signal’s value during render, that part of the tree subscribes. Use the signal directly in JSX (without `.value`) when possible so only the specific nodes that display it update:

```tsx
function App() {
  const userName = signal("bob")
  const userGreeting = computed(() => `Hello, ${userName.value}!`)

  return () => (
    <div>
      <h1>{userGreeting}</h1>
      <input
        value={userName}
        oninput={(e) => (userName.value = (e.target as HTMLInputElement).value)}
      />
    </div>
  )
}
```

### Two-way binding

Use the `bind:` prefix for two-way binding on inputs:

```tsx
function App() {
  const userName = signal("bob")

  return () => (
    <div>
      <input type="text" bind:value={userName} />
      <p>Hello, {userName}!</p>
    </div>
  )
}
```

### Computed signals

`computed(getter)` creates a derived signal. It is lazy and tracks dependencies. The getter can receive the previous value:

```tsx
const count = signal(0)
const double = computed(() => count.value * 2)
const withPrev = computed((prev) => count.value + (prev ?? 0))
```

### Effect

`effect` runs a callback when observed signals change. It runs immediately and is re-queued when dependencies change (microtask batching). You can pass a list of signals and receive their values in the callback:

```tsx
import { effect, signal } from "kiru"

const userName = signal("bob")

const handle = effect(() => {
  console.log("Name:", userName.value)
})

effect([userName], (name) => {
  console.log("Name:", name)
})

handle.stop()
handle.start()
```

## Ref

`ref(initialValue)` creates a mutable ref object (e.g. for DOM nodes or timers). No reactivity:

```tsx
import { ref } from "kiru"

function Input() {
  const inputRef = ref<HTMLInputElement | null>(null)

  return () => (
    <input
      ref={inputRef}
      onblur={() => inputRef.current?.focus()}
    />
  )
}
```

## Lifecycles

All lifecycle hooks must be called synchronously during component initialization (in the component body, not inside the render function).

- **onMount(callback)**: Runs after the component is first painted. Return a function to clean up on unmount.
- **onBeforeMount(callback)**: Runs before paint, after DOM nodes are created.
- **onCleanup(fn)**: Registers a teardown that runs when the component unmounts. Can be called from lifecycle hooks or at top level of the component.

Example:

```tsx
import { signal, onMount, onCleanup } from "kiru"

function Timer() {
  const seconds = signal(0)

  onMount(() => {
    const id = setInterval(() => (seconds.value += 1), 1000)
    return () => clearInterval(id)
  })

  onCleanup(() => console.log("Timer unmounting"))

  return () => <p>Seconds: {seconds}</p>
}
```

## Derive — Fine-grained reactivity in JSX

`<Derive from={signalOrSignals} fallback={...}>` subscribes to the given signal(s) and re-renders only the Derive subtree when they change. Use it to avoid re-running entire components.

```tsx
import { signal, Derive } from "kiru"

function App() {
  const name = signal("bob")

  return () => (
    <div>
      <Derive from={name}>
        {(n) => <h1>Hello, {n}!</h1>}
      </Derive>
    </div>
  )
}
```

Multiple sources and fallback:

```tsx
<Derive from={{ name, count }} fallback={<div>Loading...</div>}>
  {({ name, count }) => (
    <p>{name} — {count}</p>
  )}
</Derive>
```

## For — Reactive lists

`<For each={signal} fallback={...}>` iterates over a signal’s value and updates only when the list changes (fine-grained list updates):

```tsx
import { For, signal } from "kiru"

function TodoList() {
  const todos = signal([{ id: "1", text: "One" }, { id: "2", text: "Two" }])

  return () => (
    <ul>
      <For each={todos} fallback={<li>No items</li>}>
        {({ id, text }) => (
          <li key={id}>
            {text}
            <button onclick={() => remove(id)}>Remove</button>
          </li>
        )}
      </For>
    </ul>
  )
}
```

## Async data: statefulPromise + Derive

Use `statefulPromise` to create a promise that can be observed, and `<Derive from={...} fallback={...}>` to render it. Derive can show stale data while revalidating or show only the fallback until data is ready:

```tsx
import { signal, statefulPromise, Derive } from "kiru"

function Page() {
  const count = signal(0)
  const data = statefulPromise(async (signal) => {
    const res = await fetch("https://api.example.com/data", { signal })
    if (!res.ok) throw new Error(res.statusText)
    return res.json()
  })

  return () => (
    <Derive from={{ data, count }} fallback={<div>Loading...</div>}>
      {({ data, count }, isStale) => (
        <div className={isStale ? "opacity-50" : ""}>
          <p>Count: {count}</p>
          <ul>
            {data.items.map((item) => <li key={item.id}>{item.name}</li>)}
          </ul>
        </div>
      )}
    </Derive>
  )
}
```

Use the `mode` prop on Derive: `"swr"` (default) or `"fallback"` to control whether stale data is shown.

## Context

Context is a **component** for composition: it passes a value down the tree. Create it with `createContext(initialValue)`; the result is a component you use with a `value` prop. Children read the value via `useContext(context)` (or the initial value if no context component is above them).

**Context does not trigger any reactivity.** It is purely a way to supply a value to descendants. For reactive state, put **signals** (or objects containing signals) in the context value; consumers then observe those signals and update accordingly.

```tsx
import { createContext, useContext } from "kiru"

const ThemeContext = createContext<"light" | "dark">("light")

function App() {
  return (
    <ThemeContext value="dark">
      <Child />
    </ThemeContext>
  )
}

function Child() {
  const theme = useContext(ThemeContext)
  return <div>Theme: {theme}</div>
}
```

Example with reactive state: put a signal (or an object with signals) in the context value and use it in children so only the subscribing nodes update.

## Portal

Render children into another DOM node (e.g. modals, tooltips):

```tsx
import { Portal } from "kiru"

function App() {
  return (
    <div>
      <h1>My App</h1>
      <Portal container={() => document.getElementById("portal-root")!}>
        <div className="modal">Content in portal</div>
      </Portal>
    </div>
  )
}
```

## Transition

Animate enter/exit with a procedural, state-driven API. Use `in` (signal or boolean) and `element` (function that receives transition state and returns JSX):

```tsx
import { signal, Transition } from "kiru"

function Modal() {
  const open = signal(false)

  return () => (
    <>
      <button onclick={() => (open.value = true)}>Open</button>
      <Transition
        in={open}
        element={(state) => {
          if (state === "exited") return null
          return (
            <div className="modal" style={{ opacity: state === "entered" ? 1 : 0 }}>
              Modal content
            </div>
          )
        }}
      />
    </>
  )
}
```

## ViewTransitions

Wrap the browser View Transitions API with batching and queue management:

```tsx
import { signal, ViewTransitions } from "kiru"

const current = signal(0)

function next() {
  ViewTransitions.run(() => {
    current.value = (current.value + 1) % images.length
  })
}
```

Options: `signal` (AbortSignal) to cancel. `ViewTransitions.stop()` skips the active transition and clears the queue.

## ErrorBoundary

Catch errors in the child tree and render a fallback:

```tsx
import { ErrorBoundary } from "kiru"

<ErrorBoundary
  fallback={(err) => <div>Error: {err.message}</div>}
  onError={(err) => console.error(err)}
>
  <MaybeFailingComponent />
</ErrorBoundary>
```

## Lazy

Code-split by loading a component asynchronously:

```tsx
import { lazy } from "kiru"

const Heavy = lazy(() => import("./Heavy"))

function App() {
  return <Heavy fallback={<div>Loading...</div>} />
}
```

## FileRouter — File-based routing

**CSR:**

```ts
import { mount } from "kiru"
import { FileRouter } from "kiru/router"

mount(
  <FileRouter
    config={{
      pages: import.meta.glob("/**/index.{tsx,jsx}"),
      layouts: import.meta.glob("/**/layout.{tsx,jsx}"),
    }}
  />,
  document.getElementById("app")
)
```

**SSG (vite.config.ts):**

```ts
import kiru from "vite-plugin-kiru"

export default defineConfig({
  plugins: [
    kiru({
      ssg: {
        baseUrl: "/",
        dir: "src/pages",
        page: "index.{tsx,jsx}",
        layout: "layout.{tsx,jsx}",
        document: "document.{tsx,jsx}",
      },
      // or ssg: true for defaults
    }),
  ],
})
```

**Pages:** `pages/index.tsx` → `/`, `pages/about.tsx` → `/about`, `pages/users/[id].tsx` → `/users/:id`.

**useFileRouter:** Inside a component (in the body, before the render function), call `useFileRouter()` from `kiru/router` to get the router instance (e.g. `router.state.pathname`, `router.state.params`, `router.setHash`, `Link`).

**Page config (loader, SSG):**

```tsx
import { definePageConfig, useFileRouter } from "kiru/router"

export default function Page() {
  const router = useFileRouter()
  const id = router.state.params.id
  return () => <h1>User {id}</h1>
}

export const config = definePageConfig({
  loader: {
    load: async ({ signal, params, query }) => {
      const res = await fetch(`/api/data/${params.id}`, { signal })
      return res.json()
    },
  },
  // SSG: mode: "static", generateStaticParams: async () => [...]
})
```

## TypeScript

- **JSX**: Use the global `JSX` namespace; `JSX.Children` for children.
- **Component props**: Type the first argument of the render function (or the component’s props type).
- **Signal**: `Signal<T>` from `kiru`.
- **Ref**: `ref<T>(initialValue)`; `RefObject<T>` for refs to DOM/elements.
- **Element props**: `ElementProps<"div">` etc. from `kiru` for extending native props.

## Key differences from other frameworks

### vs React

- **State model:** State is created with `signal()`/`computed()` in the component body; components that need state return a render function so that state persists.
- **Reactivity:** Signal-based, fine-grained: only nodes that observe a signal update.
- **Built-in:** Routing, context, transitions, portals, async via statefulPromise + Derive.
- **Two-way binding:** `bind:` for inputs.

### vs Svelte

- **Syntax:** JSX/TSX instead of Svelte templates.
- **Runtime:** Framework runs at runtime; no “compile away” model.
- **State:** Explicit signals and render function; no reactive declarations in the template.

### vs Solid

- **State:** Local state = signals in component body + return a render function.
- **Lifecycles:** onMount, onBeforeMount, onCleanup — called once during setup.

## Best practices

1. **Stateful components:** If you create `signal`, `computed`, or `ref` in a component, return a **render function** (`return () => (...)` or `return (props) => (...)`) so state persists.
2. **Reactivity:** Prefer using signals directly in JSX (e.g. `{name}`) so only the dependent DOM nodes update.
3. **Lists:** Use `<For each={signal}>` instead of `signal.value.map(...)` for reactive lists.
4. **Derived UI:** Use `<Derive from={...}>` for parts of the tree that depend on one or a few signals.
5. **Async:** Use `statefulPromise` + `<Derive from={...} fallback={...}>`.
6. **Shared state:** Use Context (createContext + useContext) or shared signals in modules.
7. **Side effects and cleanup:** Use `onMount`/`onBeforeMount` and return a cleanup function, or `onCleanup`.
8. **Features as units:** Extract logic into factories (like createHashChangeDispatcher) that return init/teardown and call them from `onMount` when needed.

## Current limitations & roadmap

- **SSR:** Basic support via integrations (e.g. Vike); native solution in development.
- **Ecosystem:** Early stage.
- **Production:** Framework is stable and used in production.

**Roadmap:** Native SSR/SSG improvements, compiled component/Web Components API, community-driven features.

## Resources

- Website: https://kirujs.dev
- GitHub: https://github.com/kirujs/kiru
- Discord: https://discord.gg/Pf9zbgBaRw
- Playground: https://stackblitz.com/~/github.com/kirujs/kiru-csr-template
- Docs: https://kirujs.dev/docs

This document is for AI/LLM understanding of Kiru. For the latest details, see https://kirujs.dev and the GitHub repo.
